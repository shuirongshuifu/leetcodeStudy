## 问题描述
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```js
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。
之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```
> 力扣原题目地址：https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string

## 解决方案
### 方案一 数组栈思想

```js
var removeDuplicates = function (s) {
    let stack = [] // 1. 创建一个栈数组，用于存放数据
    for (let i = 0; i < s.length; i++) { // 2. 遍历字符串执行入栈出栈操作
        // 3. 一开始栈是空的，所以不用看if，直接看else的操作
        if (stack.at(-1) === s[i]) { // 5. 若栈中已有的顶部数据项（最后一项）和即将要入栈的数据一致，就说明是重复项了
            stack.pop() // 6. 重复项的话，就删除呗（即将入栈的这一项忽略，同时把栈顶部数据即最后一项删除）
        } 
        // 4. 新来的这一项，入栈（尾部追加）
        else {
            stack.push(s[i]) // 栈是特殊的数组，只会用到尾部增push、尾部删pop
        }
    }
    // 7. 最后栈中存放的数据就是不相邻重复的数据
    return stack.join('') // 8. 然后把栈数组转成字符串返回出来即可
};
```
栈的应用挺多的，不过如果遇到`"成对"`的问题需求，可以考虑使用`栈的思想`去解决。即，`尾部增、尾部删。`

于是乎，这道题，也可以使用`字符串进行“栈”的操作`，反正都是尾部增尾部删呗

- 字符串尾部增，考虑：`str = str + 'newStr'`
- 字符串尾部删，考虑：`str = str.slice(0,-1)`

> 删除字符串最后一项，即为截取保留字符串第0项到倒数第二项。注意：slice方法截取字符串两个参数，截取的时候不包括最后一项，所以是`str = str.slice(0,-1)`

于是乎，便有以下解法：

### 方案二 字符串栈思想

```js
var removeDuplicates = function (s) {
    let str = '' // 和上方基本一样，只不过由数组栈换成了字符串了。故不赘述了
    for (let i = 0; i < s.length; i++) {
        if (str.at(-1) == s[i]) {
            str = str.slice(0, -1) // 尾部删
        } else {
            str = str + s[i] // 尾部增
        }
    }
    return str
};
```
## 总结
**`当遇到成对出现的问题时候，考虑使用栈的思想去操作...`**

因为尾部增和尾部删刚好是可以去成对操作的