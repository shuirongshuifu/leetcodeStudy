## 题目描述
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

示例 1:
```js
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```
示例 2:
```js
输入: nums = [0]
输出: [0]
```
> 力扣原题目地址：https://leetcode.cn/problems/move-zeroes

## 思路分析
### 解法一 遍历统计0出现了几次并删除之，最后根据0出现的次数往尾部追加0

```js
var moveZeroes = function (nums) {
    let count = 0 // 1. 定义一个变量，用来统计0出现的次数
    for (let i = 0; i < nums.length; i++) { // 2. 遍历这个数组，看看0出现了几次
        if (nums[i] == 0) { // 3. 如果遇到的不是0，不做任何操作；如果遇到0了，就把0删掉
            nums.splice(i, 1) // 4. 把遇到的这一项（0）给删除掉
            i-- // 5. 注意 数组塌陷，索引统一往前平移一位
            count = count + 1 // 6. 然后统计一下0出现的次数
        }
    }
    for (let i = 0; i < count; i++) { // 7. 根据0出现的次数，决定往数组的尾部追加几个0
        nums.push(0) // 8. 出现了几个0，最后就追加几个0,
    }
};
```
这种方式，需要遍历两次，我们遍历一次也是可以解决的，思路略有相似。如下代码
### 解法二 尾部追加一个结束项标识，遍历遇到0删除之

```js
 var moveZeroes = function (nums) {
    nums.push('endFlag') // 1. 手动在数组的最后，追加一项，用于判断是否遍历到最后的标识
    for (let i = 0; i < nums.length; i++) { // 2. 遍历这个数组
        // 3. 一开始肯定不是最后一项的标识，所以继续往后看
        if (nums[i] == 'endFlag') { // 8. 当遇到之前我们手动添加的'endFlag'标识的时候，就说明原来的数组遍历一遍了
            nums.splice(i, 1) // 9. 最后再把之前手动添加的标识给删掉就行啦，搞定
            return
        }
        if (nums[i] === 0) { // 4. 当遇到0的时候做移动零操作
            nums[nums.length] = 0 // 5. 先再数组的最后的位置添加一个0
            nums.splice(i, 1) // 6. 然后在把当前的0删除掉，这样也可以理解为移动0
            i-- // 7. 注意数组删除掉一个元素以后，数组的索引塌陷，后续的索引都会往前进一位，所以需要再统一扣除1位，以达到平衡
        }
    }
};
```
## 总结
在实际工作中，时间复杂度，要优先与空间复杂度，因为空间复杂度问题，多增加点内存就行了。但是时间复杂度，才是我们写代码追求的极速目标。所以，能遍历一次的，最好不要遍历两次。至于多定义几个变量导致多用了一些内存，基本上可以忽略的